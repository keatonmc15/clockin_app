<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Employee Time Clock</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

  <style>
    body { background: #f6f7fb; }
    .brand-card { border: 0; border-radius: 18px; }
    .brand-logo { max-height: 56px; width: auto; }
    .big-btn { padding: 14px 16px; font-size: 1.15rem; border-radius: 14px; }
    .muted { color: #6c757d; }
    .status-box { border-radius: 14px; }
    .tiny { font-size: .9rem; }
    code { font-size: .95em; }
  </style>
</head>
<body>
  <div class="container py-4" style="max-width: 520px;">
    <div class="card shadow-sm brand-card">
      <div class="card-body p-4">

        <div class="d-flex align-items-center justify-content-between mb-3">
          <img class="brand-logo" src="{{ url_for('static', filename='img/logo.png') }}" alt="Company Logo">
          <span class="badge text-bg-dark">Time Clock</span>
        </div>

        <h2 class="mb-1">Employee Time Clock</h2>
        <div class="muted mb-3">Enter your PIN and Store Code.</div>

        <!-- CLOCKED-IN BANNER -->
        <div id="clockedBanner" class="alert alert-success status-box tiny d-none" role="alert">
          <div class="fw-semibold">CLOCKED IN: <span id="clockedName">Employee</span></div>
          <div class="tiny">Come back here to clock out when your shift ends.</div>
        </div>

        <div class="mb-3">
          <label class="form-label" for="pin">PIN</label>
          <input id="pin" class="form-control form-control-lg" inputmode="numeric" placeholder="Enter your PIN" />
        </div>

        <div class="mb-2">
          <label class="form-label" for="store_code">Store Code</label>
          <input
            id="store_code"
            class="form-control form-control-lg"
            placeholder="Start typing store name or code…"
            list="storeList"
            autocomplete="off"
            autocapitalize="characters"
            spellcheck="false"
          />
          <datalist id="storeList">
            {% for s in stores %}
              <option value="{{ s.code }}">{{ s.name }}</option>
            {% endfor %}
          </datalist>
          <div id="storeName" class="tiny muted mt-1"></div>
        </div>

        <div class="d-grid gap-2 mt-3">
          <button id="btnClockIn" class="btn btn-dark big-btn" onclick="doClockIn()">Clock In</button>
          <button id="btnClockOut" class="btn btn-outline-dark big-btn" onclick="doClockOut()">Clock Out</button>
        </div>

        <div id="status" class="alert alert-light status-box mt-3 mb-0 tiny" role="alert">
          Ready.
        </div>

        <!-- GPS DEBUG LINE -->
        <div class="mt-2 tiny muted">
          <div><span class="fw-semibold">GPS:</span> <span id="gpsPerm">—</span></div>
          <div>
            <span class="fw-semibold">Accuracy:</span>
            <span id="gpsAcc">—</span>
            <span id="gpsTime" class="ms-2"></span>
          </div>
        </div>

      </div>
    </div>

    <div class="text-center muted tiny mt-3">
      Tip: This phone will remember your last Store Code automatically.
    </div>
  </div>

<script>
  const STORES = {{ stores|tojson }};

  // ---- Local state keys ----
  const LS_CLOCKED_IN = "clocked_in";
  const LS_CLOCKED_NAME = "clocked_in_name";
  const LS_CLOCKED_SHIFT_ID = "clocked_in_shift_id";
  const LS_LAST_STORE = "last_store_code";
  const LS_LAST_PIN = "last_pin"; // used for periodic pings

  let BUSY = false;

  // ---- Ping config ----
  const PING_EVERY_MS = 15 * 60 * 1000;   // 15 minutes
  const PING_MAX_AGE_MS = 60 * 1000;      // allow cached GPS up to 1 minute for pings
  let pingTimer = null;

  function isClockedIn() {
    return localStorage.getItem(LS_CLOCKED_IN) === "1";
  }

  function setClockedIn(on, payload = {}) {
    if (on) {
      localStorage.setItem(LS_CLOCKED_IN, "1");
      if (payload.name) localStorage.setItem(LS_CLOCKED_NAME, payload.name);
;
      if (payload.shift_id !== undefined && payload.shift_id !== null) {
        localStorage.setItem(LS_CLOCKED_SHIFT_ID, String(payload.shift_id));
      }
    } else {
      localStorage.removeItem(LS_CLOCKED_IN);
      localStorage.removeItem(LS_CLOCKED_NAME);
      localStorage.removeItem(LS_CLOCKED_SHIFT_ID);
    }
    updateUI();
  }

  function setStatus(msg, kind="light") {
    const el = document.getElementById("status");
    el.className = `alert alert-${kind} status-box mt-3 mb-0 tiny`;
    el.textContent = msg;
  }

  // ---- GPS debug helpers ----
  function setGpsInfo({ permText="—", accuracyM=null, ts=null } = {}) {
    const permEl = document.getElementById("gpsPerm");
    const accEl = document.getElementById("gpsAcc");
    const timeEl = document.getElementById("gpsTime");

    permEl.textContent = permText;

    if (accuracyM === null || accuracyM === undefined) {
      accEl.textContent = "—";
    } else {
      accEl.textContent = `±${Math.round(accuracyM)} m`;
    }

    if (!ts) {
      timeEl.textContent = "";
    } else {
      const d = new Date(ts);
      timeEl.textContent = `(${d.toLocaleTimeString()})`;
    }
  }

  async function refreshGpsPermission() {
    if (!navigator.geolocation) {
      setGpsInfo({ permText: "Not supported" });
      return;
    }

    if (!("permissions" in navigator) || !navigator.permissions.query) {
      setGpsInfo({ permText: "Unknown" });
      return;
    }

    try {
      const perm = await navigator.permissions.query({ name: "geolocation" });
      const label =
        perm.state === "granted" ? "Allowed" :
        perm.state === "denied"  ? "Denied" :
        "Needs approval";

      setGpsInfo({ permText: label });
      perm.onchange = () => refreshGpsPermission();
    } catch (e) {
      setGpsInfo({ permText: "Unknown" });
    }
  }

  function updateGpsFromPosition(pos) {
    setGpsInfo({
      permText: "Allowed",
      accuracyM: pos?.coords?.accuracy ?? null,
      ts: pos?.timestamp ?? Date.now()
    });
  }

  // ✅ Canonical store code = lowercase
  function normalizeStoreInput() {
    const el = document.getElementById("store_code");
    const raw = (el.value || "");
    const norm = raw.trim().toLowerCase();
    if (el.value !== norm) el.value = norm;
    return norm;
  }

  function updateStoreName() {
    const code = normalizeStoreInput();
    const match = STORES.find(s => String(s.code).toLowerCase() === code);
    document.getElementById("storeName").textContent = match ? `Selected: ${match.name}` : "";
  }

  function setBusy(on, which="") {
    BUSY = on;
    const btnIn = document.getElementById("btnClockIn");
    const btnOut = document.getElementById("btnClockOut");

    btnIn.disabled = on || isClockedIn();
    btnOut.disabled = on || !isClockedIn();

    if (on) {
      if (which === "in") btnIn.textContent = "Clocking in…";
      if (which === "out") btnOut.textContent = "Clocking out…";
    } else {
      btnIn.textContent = "Clock In";
      btnOut.textContent = "Clock Out";
    }

    updateUI();
  }

  // ✅ UPDATED: allow PIN typing while clocked in
  function updateUI() {
    const banner = document.getElementById("clockedBanner");
    const clockedNameEl = document.getElementById("clockedName");

    const pinInput = document.getElementById("pin");
    const storeInput = document.getElementById("store_code");
    const btnIn = document.getElementById("btnClockIn");
    const btnOut = document.getElementById("btnClockOut");

    const clocked = isClockedIn();
    const name = localStorage.getItem(LS_CLOCKED_NAME) || "Employee";

    // Banner
    if (clocked) {
      banner.classList.remove("d-none");
      clockedNameEl.textContent = name;
    } else {
      banner.classList.add("d-none");
    }

    // Inputs:
    // - PIN stays usable so employee can type PIN to clock out
    // - Store code stays locked while clocked in (prevents accidental store changes)
    pinInput.disabled = BUSY;               // ✅ allow PIN entry while clocked in
    storeInput.disabled = clocked || BUSY;  // ✅ lock store while clocked in

    // Buttons
    btnIn.disabled = BUSY || clocked;
    btnOut.disabled = BUSY || !clocked;

    // Nice UX: focus PIN when clocked in
    if (clocked && !BUSY) {
      pinInput.focus();
    }

    window.__shouldWarnOnLeave = clocked;
  }

  // ---- Ping helpers ----
  function stopPingLoop() {
    if (pingTimer) {
      clearInterval(pingTimer);
      pingTimer = null;
    }
  }

  async function sendPing(pin) {
    if (!pin) return;

    let loc;
    try {
      loc = await getLocation({ timeoutMs: 15000, maximumAgeMs: PING_MAX_AGE_MS });
    } catch (e) {
      return;
    }

    try {
      await fetch("/api/ping", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ pin, lat: loc.lat, lng: loc.lng })
      });
    } catch (e) {}
  }

  function startPingLoop(pin) {
    stopPingLoop();
    if (!pin) return;

    localStorage.setItem(LS_LAST_PIN, pin);

    sendPing(pin).catch(() => {});

    pingTimer = setInterval(() => {
      if (!isClockedIn()) return stopPingLoop();
      const p = (localStorage.getItem(LS_LAST_PIN) || "").trim();
      if (p) sendPing(p).catch(() => {});
    }, PING_EVERY_MS);
  }

  window.addEventListener("load", () => {
    const saved = localStorage.getItem(LS_LAST_STORE);
    if (saved) document.getElementById("store_code").value = saved;

    updateStoreName();
    updateUI();

    refreshGpsPermission();
    getLocation().catch(() => {});

    if (isClockedIn()) {
      const p = (localStorage.getItem(LS_LAST_PIN) || "").trim();
      if (p) startPingLoop(p);
    }
  });

  document.getElementById("store_code").addEventListener("input", () => {
    updateStoreName();
    const code = normalizeStoreInput();
    if (code) localStorage.setItem(LS_LAST_STORE, code);
  });

  window.addEventListener("beforeunload", (e) => {
    if (!window.__shouldWarnOnLeave) return;
    e.preventDefault();
    e.returnValue = "";
  });

  document.addEventListener("visibilitychange", () => {
    if (!document.hidden && isClockedIn()) {
      const p = (localStorage.getItem(LS_LAST_PIN) || "").trim();
      if (p) sendPing(p).catch(() => {});
    }
  });

  function getLocation({ timeoutMs=10000, maximumAgeMs=0 } = {}) {
    return new Promise((resolve, reject) => {
      if (!navigator.geolocation) {
        setGpsInfo({ permText: "Not supported" });
        return reject(new Error("Geolocation not supported."));
      }

      navigator.geolocation.getCurrentPosition(
        pos => {
          updateGpsFromPosition(pos);
          resolve({ lat: pos.coords.latitude, lng: pos.coords.longitude, accuracy: pos.coords.accuracy });
        },
        err => {
          if (err && err.code === 1) setGpsInfo({ permText: "Denied" });
          else if (err && err.code === 2) setGpsInfo({ permText: "Unavailable" });
          else if (err && err.code === 3) setGpsInfo({ permText: "Timeout" });
          else setGpsInfo({ permText: "Error" });

          reject(err);
        },
        { enableHighAccuracy: true, timeout: timeoutMs, maximumAge: maximumAgeMs }
      );
    });
  }

  async function doClockIn() {
    if (BUSY) return;
    if (isClockedIn()) return setStatus("You are already clocked in.", "warning");

    const pin = (document.getElementById("pin").value || "").trim();
    const qr_token = normalizeStoreInput();

    if (!pin) return setStatus("Enter your PIN.", "warning");
    if (!qr_token) return setStatus("Enter your Store Code.", "warning");

    setBusy(true, "in");
    setStatus("Getting location...");

    let loc;
    try { loc = await getLocation({ timeoutMs: 10000, maximumAgeMs: 0 }); }
    catch(e) {
      setBusy(false);
      return setStatus("Location failed. Turn on location services and try again.", "danger");
    }

    setStatus("Clocking in...");
    const res = await fetch("/api/clockin", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ pin, qr_token, lat: loc.lat, lng: loc.lng })
    });

    const data = await res.json().catch(() => ({}));
    if (!res.ok) {
      setBusy(false);
      return setStatus(data.error || "Clock-in failed.", "danger");
    }

    setClockedIn(true, { name: data.employee || "", shift_id: data.shift_id });
    setStatus(data.message || "Clock-in successful.", "success");
    setBusy(false);

    startPingLoop(pin);
  }

  // ✅ UPDATED: clock out no longer requires store code
  async function doClockOut() {
    if (BUSY) return;

    const pin = (document.getElementById("pin").value || "").trim();
    if (!pin) return setStatus("Enter your PIN.", "warning");

    setBusy(true, "out");
    setStatus("Getting location...");

    let loc;
    try { loc = await getLocation({ timeoutMs: 10000, maximumAgeMs: 0 }); }
    catch(e) {
      setBusy(false);
      return setStatus("Location failed. Turn on location services and try again.", "danger");
    }

    setStatus("Clocking out...");
    const res = await fetch("/api/clockout", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ pin, lat: loc.lat, lng: loc.lng })
    });

    const data = await res.json().catch(() => ({}));

    if (!res.ok) {
      const msg = (data.error || "Clock-out failed.").toLowerCase();
      if (msg.includes("no open shift")) {
        setClockedIn(false);
        stopPingLoop();
        localStorage.removeItem(LS_LAST_PIN);
        setStatus("No open shift found. It may have been closed by an admin.", "warning");
        setBusy(false);
        return;
      }
      setBusy(false);
      return setStatus(data.error || "Clock-out failed.", "danger");
    }

    setClockedIn(false);
    stopPingLoop();
    localStorage.removeItem(LS_LAST_PIN);

    const worked = data.human ? ` Worked: ${data.human}` : "";
    setStatus((data.message || "Clock-out successful.") + worked, "success");
    setBusy(false);
  }
</script>
</body>
</html>
